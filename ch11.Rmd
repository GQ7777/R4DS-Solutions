---
title: "Ch11"
output:
  html_document:
    df_print: paged
---

```{r}
library(tidyverse)
# stringr now belongs to the tidyverse core
```


## Exercises 14.2.5

In code that doesn’t use stringr, you’ll often see paste() and paste0(). What’s the difference between the two functions? What stringr function are they equivalent to? How do the functions differ in their handling of NA?

`paste` and `paste0` are the same but `paste0` has `sep = ""` by default and `paste` has `sep = " "` by default.

`str_c` is the equivalent `stringr` function.

```{r}
str_c(c("a", "b"), collapse = ", ")
```

```{r}
str_c(c("a", "b"), NA)
# In `str_c` everything that is pasted with an NA is an NA

paste0(c("a", "b"), NA)
# But in paste0 NA gets converted to a character string a pasted together. To mimic the same behaviour, replace the NA to a string with:
str_c(c("a", "b"), str_replace_na(NA))
```

In your own words, describe the difference between the sep and collapse arguments to str_c().

`sep` is what divides what you paste together within a vector of strings. `collapse` is the divider of a single pasted vector of strings.

Use str_length() and str_sub() to extract the middle character from a string. What will you do if the string has an even number of characters?

```{r}
uneven <- "one"
even <- "thre"

str_sub(even, str_length(even) / 2, str_length(even) / 2)

# Automatically rounds up the lower digit
str_sub(uneven, str_length(uneven) / 2, str_length(uneven) / 2)
```
One solution would be to round the the highest digit with `ceiling`.

What does str_wrap() do? When might you want to use it?

```{r}
str_wrap(
    "Hey, so this is one paragraph
    I'm interested in writing but I
    think it might be too long. I just
    want to make sure this is in the right format",
    width = 60, indent = 2, exdent = 1
) %>% cat()
```

This might be interesting to output messages while running scripts or in packages.
What does str_trim() do? What’s the opposite of str_trim()?

Write a function that turns (e.g.) a vector c("a", "b", "c") into the string a, b, and c. Think carefully about what it should do if given a vector of length 0, 1, or 2.

```{r}

str_paster <- function(x, collapse = ", ") {
  str_c(x, collapse = collapse)
}

tr <- letters[1:3]
str_paster(tr)

tr <- letters[1:2]
str_paster(tr)

tr <- letters[1]
str_paster(tr)

tr <- letters[0]
str_paster(tr)
```
It always returns a character, even if the vector is empty.

## 14.3.1.1 Exercises

Explain why each of these strings don’t match a \: "\", "\\", "\\\".

"\" won't match anything because "\" needs to be accompanied by two "\\" to escape "\"
"\" won't match "\\" because because "\" is actualy "\\" and needs double escaping so "\\\\" will match it.

Same for "\\\".


How would you match the sequence "'\?

str_view("\"'\\", "\"'\\\\")

What patterns will the regular expression \..\..\.. match? How would you represent it as a string?

It matches a string similar to .a.b.c So every '\.' matches a literal dot and . matches any character except a new line.

```{r}
str_view(".a.b.c", "\\..\\..\\..")
```

## Exercises 14.3.2.1

How would you match the literal string "$^$"?

Given the corpus of common words in stringr::words, create regular expressions that find all words that:

Start with "y".
```{r}
str_bring <- function(string, pattern) {
  string[str_detect(string, pattern)]
}

str_bring(words, "^y")
```

End with "x"

```{r}
str_bring(words, "x$")
```

Are exactly three letters long. (Don’t cheat by using str_length()!)

```{r}
str_bring(words, "^.{3}$")
```

Have seven letters or more.

```{r}
str_bring(words, "^.{7,}$")
```

Since this list is long, you might want to use the match argument to str_view() to show only the matching or non-matching words.

## Exercises 14.3.3.1

Create regular expressions to find all words that:

Start with a vowel.

```{r}
str_bring(words, "^[aeiou]")
```

That only contain consonants. (Hint: thinking about matching “not”-vowels.)

```{r}
str_bring(words, "^[^aeiou]")
```

End with ed, but not with eed.

```{r}
str_bring(words, "[^e]ed$")
```

End with ing or ise.

```{r}
str_bring(words, "i(ng|se)$")
```

Empirically verify the rule "i before e except after c".

```{r}
str_bring(words, "ie|[^c]ie")
```


Is "q"" always followed by a "u"?

```{r}
str_bring(words, "q[^u]")
```

Yes!

Write a regular expression that matches a word if it’s probably written in British English, not American English.

A bit hard. The closest is: "ou|ise^|ae|oe|yse^"

```{r}
str_bring(words, "ou|ise^|ae|oe|yse^")
```

But see: https://jrnold.github.io/r4ds-exercise-solutions/strings.html

Create a regular expression that will match telephone numbers as commonly written in your country.

```{r}
x <- c("34697382009", "18093438932", "18098462020")
str_bring(x, "^34.{9}$")
```
or

```{r}
x <- c("123-456-7890", "1235-2351")
str_bring(x, "\\d{3}-\\d{3}-\\d{4}")
```

## Exercises 14.3.4.1

Describe the equivalents of ?, +, * in {m,n} form.

? is {,1}
+ is {1,}
* has no equivalent

Describe in words what these regular expressions match: (read carefully to see if I’m using a regular expression or a string that defines a regular expression.)

^.*$ 

Matches any string

"\\{.+\\}"

Matches any string with curly braces.

\d{4}-\d{2}-\d{2}

Matches a set of numbers in this format dddd-dd-dd

"\\\\{4}"

It matches four back slashes.

```{r}
str_bring("\\\\\\\\", "\\\\{4}")
```

Create regular expressions to find all words that:

Start with three consonants.

```{r}
str_bring(words, "^[^aeiou]{3}")
```

Have three or more vowels in a row.

```{r}
str_bring(words, "[aeiou]{3,}")
```


Have two or more vowel-consonant pairs in a row.

```{r}
str_bring(words, "[^aeiou][aeiou]{2,}")
```

Solve the beginner regexp crosswords at https://regexcrossword.com/challenges/beginner.


## Exercises 14.3.5.1
Describe, in words, what these expressions will match:

(.)\1\1

Any character repeated three times in a row.

```{r}
str_bring(c("aaa", "aaba"), "(.)\\1\\1")
```

"(.)(.)\\2\\1"

Any two characters repeated 3 times
```{r}
str_bring(c("ababab", "ababac"), "(.)(.)\\2")
```


(..)\1
"(.).\\1.\\1"
"(.)(.)(.).*\\3\\2\\1"
Construct regular expressions to match words that:

Start and end with the same character.

Contain a repeated pair of letters (e.g. “church” contains “ch” repeated twice.)

Contain one letter repeated in at least three places (e.g. “eleven” contains three “e”s.)

